<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git使用笔记</title>
    <link href="/2020/07/11/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/11/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>其实很早以前就知道git了，但是之前真的只是知道一些皮毛。现在想想确实挺后悔当时没有好好学git的。由于工作的最近频繁使用git进行代码的版本控制，学习到了不少东西，在此记录一下。</p></blockquote><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p><img src="https://img.alicdn.com/imgextra/i2/1839819974/O1CN01PRbuoy2NY8yDaVbWF_!!1839819974.png" srcset="/img/loading.gif" alt=""></p><h3 id="初始化Git并上传到Github"><a href="#初始化Git并上传到Github" class="headerlink" title="初始化Git并上传到Github"></a>初始化Git并上传到Github</h3><pre><code>git initgit add *    //也可以使用git add -u 添加已经跟踪的文件，或者git add 指定特定目录。git commit -m &quot;first commit&quot; // 使用 git commit -s &quot;多行commit&quot;git remote add origin https://github.com/hanxinyumeng/myNotes.gitgit push -u origin master</code></pre><h3 id="保存账号和密码"><a href="#保存账号和密码" class="headerlink" title="保存账号和密码"></a>保存账号和密码</h3><pre><code>git config --global credential.helper storegit pull /git push (这里需要输入用户名和密码，以后就不用啦)</code></pre><h3 id="添加新的更改获取新的文件"><a href="#添加新的更改获取新的文件" class="headerlink" title="添加新的更改获取新的文件"></a>添加新的更改获取新的文件</h3><pre><code>git add *git commit -m &quot;备注&quot;    git push  //git push --set-upstream origin test  推送到远程分支，并且跟踪远程分支origin test</code></pre><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code>git branch new_branch_namegit checkout -b new_branch_name  //创建分支，并切换到新分支上</code></pre><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre><code>git branch -a //显示所有分支git branch -vva //显示所有分支及详细信息git branch -u origin test  //为当前分支设置远程分支</code></pre><h3 id="切换分支及相关其他操作"><a href="#切换分支及相关其他操作" class="headerlink" title="切换分支及相关其他操作"></a>切换分支及相关其他操作</h3><pre><code>git checkout branch_name              //切换到指定分支git checkout branch_name  file_name //从其他分支拉取文件到当前分支git checkout -b new_branch_name  -t  origin test  //创建当前分支并跟踪到远程分支origin test</code></pre><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre><code>git log       //显示所有的log信息git log -p -2 //显示最近两次的log信息，及diff内容git log --author=“author”    // 显示某个作者的log内容git show commit_id           //显示某次提交的具体修改git blame -L 222,227 file_name  //查看文件file_name中222行到227行代码提交的日志</code></pre><h3 id="删除文件及分支"><a href="#删除文件及分支" class="headerlink" title="删除文件及分支"></a>删除文件及分支</h3><ul><li>删除文件:</li></ul><pre><code>git rm test.txt   //删除本地文件git rm folder_name -r -f //删除本地文件夹git commit -m &quot;delete file&quot;  //同步到分支git push origin test         //同步到远程分支</code></pre><ul><li>删除分支:</li></ul><pre><code>git branch -d branch_name // 删除本地分支branch_namegit push origin  --delete branch_name // 删除远程branch_name分支</code></pre><h3 id="diff命令总结"><a href="#diff命令总结" class="headerlink" title="diff命令总结"></a>diff命令总结</h3><pre><code>git diff //比较工作目录和暂存区之间的差别git diff branch1_name  branch2_name //比较两个分支最新提交的区别git diff HEAD  //比较工作区与最新本地版本库之间的区别git diff commit_id  //比较工作区与指定的commit_id之间的区别</code></pre><h3 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h3><pre><code>git diff &gt; patch_name   // 将差别生成一个补丁文件git apply patch_name    //在当前工作区应用补丁</code></pre><ul><li>打补丁时经常会遇见冲突的问题，所以可以在应用补丁的时候先试用<code>git apply --check patch_name</code>检查一下，如果没有任何输出，说明可以顺利试用这个path。如果有冲突，也可以先使用<code>git apply patch_name</code>然后再去相应冲突文件解冲突，解冲突后再提交。</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code>* 使用git log 查看commit id* 使用 git  reset --hard    加commit id       </code></pre><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><ul><li><p>git fetch 与git pull 最大的不同是： git pull 拉下代码后会与 当前分支进行合并，而git fetch 不会进行合并。</p><p>git pull 等价于以下两步:</p><ol><li><p>经命令中的 pull 换成 fetch, 执行之…</p></li><li><p>git merge FETCH_HEAD</p></li></ol></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>git pull :将服务器代码拉取到本地分支，不会覆盖改动的代码（只有当服务器与本地同时改动同一部分的代码时才会提示冲突）。</li></ul><ul><li>git stash ：将本地改动暂时移除（保存 在git的缓存）；<br>git stash list :查看分支的git缓存；<br>git stash pop :将git缓存的代码改动添加到本地。</li></ul><ul><li>git cherry-pick可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用git cherry-pick了。详情请看 <a href="https://blog.csdn.net/FightFightFight/article/details/81039050" target="_blank" rel="noopener">详细教程</a>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux-字符设备驱动框架</title>
    <link href="/2020/05/03/linux-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/05/03/linux-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-字符设备基本框架"><a href="#linux-字符设备基本框架" class="headerlink" title="linux 字符设备基本框架"></a>linux 字符设备基本框架</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul><li>自动申请设备号   </li><li>自动创建设备节点       </li></ul><pre><code>#include &lt;linux/init.h&gt;     #include &lt;linux/module.h&gt;    #include &lt;linux/cdev.h&gt;    #include &lt;linux/fs.h&gt;    #include &lt;linux/device.h&gt;    dev_t devno;    //设备号，高12为为主设备号， 低20位为次设备号static const unsigned int baseminor=0;   //次设备号起始static const unsigned int dev_count=3;    //设备个数static char *demo_name=&quot;demo_dev&quot;;         // 设备名称static struct cdev *demo_cdev;             //cdev 结构体指针static struct class* demo_class;           //class 结构体指针static int demo_open (struct inode *inode, struct file *file){    printk(KERN_INFO &quot;---%s---%s---%d---\n&quot;,__FILE__,__func__,__LINE__);    return 0;}static ssize_t demo_write (struct file *file, const char __user *user, size_t size, loff_t *loff_t){    printk(KERN_INFO &quot;---%s---%s---%d---\n&quot;,__FILE__,__func__,__LINE__);    return 0;}static int demo_release (struct inode *inode, struct file *file){    printk(KERN_INFO &quot;---%s---%s---%d---\n&quot;,__FILE__,__func__,__LINE__);    return 0;}//Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用//将驱动程序操作连接到设备编号struct file_operations fops={    .owner=THIS_MODULE,    .open=demo_open,    .write=demo_write,    .release=demo_release,};// 每个函数的的输入输出信息都可以使用source insight 在linux 源码中找到static int __init demo_init(void){    int ret;     //0. 让内核分配给我们一个尚未使用的主设备号    ret=alloc_chrdev_region(&amp;devno,baseminor,dev_count,demo_name);    // 错误判断    if (ret&lt;0){        printk(KERN_INFO &quot;alloc_chrdev_region  failed------\n&quot;);        goto err1;    }    printk(KERN_INFO&quot;major=%d\n&quot;,MAJOR(devno));  //打印出申请的主设备号    //1. 申请cdev 结构体内存    demo_cdev=cdev_alloc();    if(NULL==demo_cdev){        printk(KERN_INFO&quot;demo_cdev  failed   --\n&quot;);        goto err2;    }    //2. 对cdev 结构体 进行初始化    cdev_init(demo_cdev,&amp;fops);    //3. 将cdev结构体加入到系统当中    ret=cdev_add(demo_cdev,devno,dev_count);    if (ret&lt;0){        printk(KERN_INFO&quot;cdev_add  failed   --\n&quot;);        goto err2;    }    //一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建  一个类，这个类存放于sysfs下面，    demo_class=class_create(THIS_MODULE,demo_name);    if(IS_ERR(demo_class)){        printk(KERN_INFO&quot;class_create failed --\n&quot;);        goto err3;    }    //调用device_create(…)函数来在/dev目录下创建相应的设备节点    device_create(demo_class,NULL,devno,NULL,demo_name);    printk(KERN_INFO &quot;---%s---%s---%d---\n&quot;,__FILE__,__func__,__LINE__);    return 0;err3:    cdev_del(demo_cdev);err2:    unregister_chrdev_region(devno,dev_count);err1:    return ret;}static void __exit demo_exit(void){    class_destroy(demo_class);    device_destroy(demo_class,devno);    cdev_del(demo_cdev);    unregister_chrdev_region(devno,dev_count);    printk(KERN_INFO &quot;---%s---%s---%d---\n&quot;,__FILE__,__func__,__LINE__);}module_init(demo_init);module_exit(demo_exit);MODULE_LICENSE(&quot;GPL&quot;); //描述模块的许可证</code></pre><h2 id="编译驱动模块"><a href="#编译驱动模块" class="headerlink" title="编译驱动模块"></a>编译驱动模块</h2><p>Makefile 文件如下    </p><pre><code class="makefile">KDIR=/home/qiu/linux2.6.35-source/linux-2.6.35.3   <span class="comment">#内核路径</span><span class="section">all:</span>    make -C <span class="variable">$(KDIR)</span> M=`pwd`  modules<span class="section">clean:</span>    make -C <span class="variable">$(KDIR)</span> M=`pwd` modules clean    rm -f modules.orderobj-m+=led_drv1.o        <span class="comment">#obj-m +=xxx.o意思是该模块不会编译到zImage</span></code></pre><p>在该目录下使用make命令完成对 文件的编译    </p><h2 id="驱动测试代码"><a href="#驱动测试代码" class="headerlink" title="驱动测试代码"></a>驱动测试代码</h2><pre><code class="c"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><span class="function"></span>{    <span class="keyword">int</span> fd;      <span class="comment">//声明设备描述符</span>    <span class="keyword">int</span> val = <span class="number">1</span>;  <span class="comment">//随便定义变量传入到</span>    fd = <span class="built_in">open</span>(<span class="string">"/dev/xxx"</span>,  O_RDWR);  <span class="comment">//根据路径打开设备</span>    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)          <span class="comment">//打开失败</span>            <span class="built_in">printf</span>(<span class="string">"can't open\n"</span>);      <span class="built_in">write</span>(fd, &amp;val, <span class="number">4</span>);  <span class="comment">//根据文件描述符调用write</span>    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><hr><p>字符设备驱动这一部分还是学了很久的，算是自己linux驱动的入门吧，Makefile这一部分忘的差不多了，接下来补一补，接下来学习更多驱动相关的内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
