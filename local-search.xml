<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>sizeof相关总结</title>
    <link href="/2020/07/19/sizeof%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/19/sizeof%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><ol><li><p>sizeof 是C语言中的一个运算符（主要sizeof不是函数，虽然用法很想函数），sizeof的作用是用来返回 （）里面的变量或者数据类型占用的内存字节数。</p></li><li><p>sizeof存在的价值？<br>主要是在不同平台下各种数据类型所占的内存字节数不仅相同（譬如int在32位系统中为4字节，在16位系统中为2字节，在64位系统为8字节）。所以程序中需要使用sizeof来判断当前变量/数据类型在当前环境下所占几个字节。</p></li><li><p>举个栗子</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">char</span> t[]=<span class="hljs-string">"hello"</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(t)=%d\n"</span>,<span class="hljs-keyword">sizeof</span>(t)); <span class="hljs-comment">//打印为6</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(t[0])=%d\n"</span>,<span class="hljs-keyword">sizeof</span>(t[<span class="hljs-number">0</span>]));<span class="hljs-comment">//打印为1</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"strlen(t)=%d\n"</span>,<span class="hljs-built_in">strlen</span>(t));<span class="hljs-comment">//打印为5，不算最后的\0</span><span class="hljs-keyword">char</span> *p=t;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(p)=%d\n"</span>,<span class="hljs-keyword">sizeof</span>(p)); <span class="hljs-comment">//打印4 ,相当于sizeof(char *)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(*p)=%d\n"</span>,<span class="hljs-keyword">sizeof</span>(*p));<span class="hljs-comment">//打印1 ，*p指向的是char类型，相当于sizeof（char）</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"strlen(p)=%d\n"</span>,<span class="hljs-built_in">strlen</span>(p));<span class="hljs-comment">//打印为5，不算最后的\0，相当于是strlen(t)</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></li><li><p>干货</p></li></ol><ul><li><p><strong>32为系统中所有指针的长度都是4</strong>    </p></li><li><p><strong>strlen是一个c库函数，用于返回一个字符串的长度（注意字符串长度不计算末尾的’\0’）,strlen接收的参数一定是字符串（字符串特征是以’\0’为结尾）</strong></p></li><li><p><strong>sizeof测试一个变量本身和sizeof测试这个变量类型的结果是一样的</strong>     </p></li><li><p><strong>sizeof参数为数组名，计算的就是数组所占的内存大小，<code>int b[100]={0}; sizeof(b)的结果就是100*sizeof（int）</code></strong></p></li><li><p>函数形参是数组时，实际传递的不是整个数组，而是数组的首地址，相当于传递的是指针</p><p>举例 :</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>])</span></span><span class="hljs-function">   </span>&#123;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(a)=%d\n"</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">// 结果等于sizeof(int)</span>   &#125;       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;     <span class="hljs-keyword">int</span> t[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;    func(t);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre></div></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git使用笔记</title>
    <link href="/2020/07/11/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/11/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>其实很早以前就知道git了，但是之前真的只是知道一些皮毛。现在想想确实挺后悔当时没有好好学git的。由于工作的最近频繁使用git进行代码的版本控制，学习到了不少东西，在此记录一下。</p></blockquote><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p><img src="https://img.alicdn.com/imgextra/i2/1839819974/O1CN01PRbuoy2NY8yDaVbWF_!!1839819974.png" srcset="/img/loading.gif" alt=""></p><h3 id="初始化Git并上传到Github"><a href="#初始化Git并上传到Github" class="headerlink" title="初始化Git并上传到Github"></a>初始化Git并上传到Github</h3><div class="hljs"><pre><code class="hljs plain">git initgit add *    &#x2F;&#x2F;也可以使用git add -u 添加已经跟踪的文件，或者git add 指定特定目录。git commit -m &quot;first commit&quot; &#x2F;&#x2F; 使用 git commit -s &quot;多行commit&quot;git remote add origin https:&#x2F;&#x2F;github.com&#x2F;hanxinyumeng&#x2F;myNotes.gitgit push -u origin master</code></pre></div><h3 id="保存账号和密码"><a href="#保存账号和密码" class="headerlink" title="保存账号和密码"></a>保存账号和密码</h3><div class="hljs"><pre><code class="hljs plain">git config --global credential.helper storegit pull &#x2F;git push (这里需要输入用户名和密码，以后就不用啦)</code></pre></div><h3 id="添加新的更改获取新的文件"><a href="#添加新的更改获取新的文件" class="headerlink" title="添加新的更改获取新的文件"></a>添加新的更改获取新的文件</h3><div class="hljs"><pre><code class="hljs plain">git add *git commit -m &quot;备注&quot;    git push  &#x2F;&#x2F;git push --set-upstream origin test  推送到远程分支，并且跟踪远程分支origin test</code></pre></div><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><div class="hljs"><pre><code class="hljs plain">git branch new_branch_namegit checkout -b new_branch_name  &#x2F;&#x2F;创建分支，并切换到新分支上</code></pre></div><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><div class="hljs"><pre><code class="hljs plain">git branch -a &#x2F;&#x2F;显示所有分支git branch -vva &#x2F;&#x2F;显示所有分支及详细信息git branch -u origin test  &#x2F;&#x2F;为当前分支设置远程分支</code></pre></div><h3 id="切换分支及相关其他操作"><a href="#切换分支及相关其他操作" class="headerlink" title="切换分支及相关其他操作"></a>切换分支及相关其他操作</h3><div class="hljs"><pre><code class="hljs plain">git checkout branch_name              &#x2F;&#x2F;切换到指定分支git checkout branch_name  file_name &#x2F;&#x2F;从其他分支拉取文件到当前分支git checkout -b new_branch_name  -t  origin test  &#x2F;&#x2F;创建当前分支并跟踪到远程分支origin test</code></pre></div><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><div class="hljs"><pre><code class="hljs plain">git log       &#x2F;&#x2F;显示所有的log信息git log -p -2 &#x2F;&#x2F;显示最近两次的log信息，及diff内容git log --author&#x3D;“author”    &#x2F;&#x2F; 显示某个作者的log内容git show commit_id           &#x2F;&#x2F;显示某次提交的具体修改git blame -L 222,227 file_name  &#x2F;&#x2F;查看文件file_name中222行到227行代码提交的日志</code></pre></div><h3 id="删除文件及分支"><a href="#删除文件及分支" class="headerlink" title="删除文件及分支"></a>删除文件及分支</h3><ul><li>删除文件:</li></ul><div class="hljs"><pre><code class="hljs plain">git rm test.txt   &#x2F;&#x2F;删除本地文件git rm folder_name -r -f &#x2F;&#x2F;删除本地文件夹git commit -m &quot;delete file&quot;  &#x2F;&#x2F;同步到分支git push origin test         &#x2F;&#x2F;同步到远程分支</code></pre></div><ul><li>删除分支:</li></ul><div class="hljs"><pre><code class="hljs plain">git branch -d branch_name &#x2F;&#x2F; 删除本地分支branch_namegit push origin  --delete branch_name &#x2F;&#x2F; 删除远程branch_name分支</code></pre></div><h3 id="diff命令总结"><a href="#diff命令总结" class="headerlink" title="diff命令总结"></a>diff命令总结</h3><div class="hljs"><pre><code class="hljs plain">git diff &#x2F;&#x2F;比较工作目录和暂存区之间的差别git diff branch1_name  branch2_name &#x2F;&#x2F;比较两个分支最新提交的区别git diff HEAD  &#x2F;&#x2F;比较工作区与最新本地版本库之间的区别git diff commit_id  &#x2F;&#x2F;比较工作区与指定的commit_id之间的区别</code></pre></div><h3 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h3><div class="hljs"><pre><code class="hljs plain">git diff &gt; patch_name   &#x2F;&#x2F; 将差别生成一个补丁文件git apply patch_name    &#x2F;&#x2F;在当前工作区应用补丁</code></pre></div><ul><li>打补丁时经常会遇见冲突的问题，所以可以在应用补丁的时候先试用<code>git apply --check patch_name</code>检查一下，如果没有任何输出，说明可以顺利试用这个path。如果有冲突，也可以先使用<code>git apply patch_name</code>然后再去相应冲突文件解冲突，解冲突后再提交。</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><div class="hljs"><pre><code class="hljs plain">* 使用git log 查看commit id* 使用 git  reset --hard    加commit id</code></pre></div><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><ul><li><p>git fetch 与git pull 最大的不同是： git pull 拉下代码后会与 当前分支进行合并，而git fetch 不会进行合并。</p><p>git pull 等价于以下两步:</p><ol><li><p>经命令中的 pull 换成 fetch, 执行之…</p></li><li><p>git merge FETCH_HEAD</p></li></ol></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>git pull :将服务器代码拉取到本地分支，不会覆盖改动的代码（只有当服务器与本地同时改动同一部分的代码时才会提示冲突）。</li></ul><ul><li>git stash ：将本地改动暂时移除（保存 在git的缓存）；<br>git stash list :查看分支的git缓存；<br>git stash pop :将git缓存的代码改动添加到本地。</li></ul><ul><li>git cherry-pick可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用git cherry-pick了。详情请看 <a href="https://blog.csdn.net/FightFightFight/article/details/81039050" target="_blank" rel="noopener">详细教程</a>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux-字符设备驱动框架</title>
    <link href="/2020/05/03/linux-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/05/03/linux-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-字符设备基本框架"><a href="#linux-字符设备基本框架" class="headerlink" title="linux 字符设备基本框架"></a>linux 字符设备基本框架</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul><li><p>自动申请设备号   </p></li><li><p>自动创建设备节点       </p><p>​        </p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;     </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;    </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/cdev.h&gt;    </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/fs.h&gt;    </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/device.h&gt;    </span></span><span class="hljs-keyword">dev_t</span> devno;    <span class="hljs-comment">//设备号，高12为为主设备号， 低20位为次设备号</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> baseminor=<span class="hljs-number">0</span>;   <span class="hljs-comment">//次设备号起始</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dev_count=<span class="hljs-number">3</span>;    <span class="hljs-comment">//设备个数</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *demo_name=<span class="hljs-string">"demo_dev"</span>;         <span class="hljs-comment">// 设备名称</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> *<span class="hljs-title">demo_cdev</span>;</span>             <span class="hljs-comment">//cdev 结构体指针</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class</span>* <span class="hljs-title">demo_class</span>;</span>           <span class="hljs-comment">//class 结构体指针</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">demo_open</span> <span class="hljs-params">(struct inode *inode, struct file *file)</span></span><span class="hljs-function"></span>&#123;printk(KERN_INFO <span class="hljs-string">"---%s---%s---%d---\n"</span>,__FILE__,__func__,__LINE__);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">demo_write</span> <span class="hljs-params">(struct file *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *user, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">loff_t</span> *<span class="hljs-keyword">loff_t</span>)</span></span><span class="hljs-function"></span>&#123;printk(KERN_INFO <span class="hljs-string">"---%s---%s---%d---\n"</span>,__FILE__,__func__,__LINE__);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">demo_release</span> <span class="hljs-params">(struct inode *inode, struct file *file)</span></span><span class="hljs-function"></span>&#123;printk(KERN_INFO <span class="hljs-string">"---%s---%s---%d---\n"</span>,__FILE__,__func__,__LINE__);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用</span><span class="hljs-comment">//将驱动程序操作连接到设备编号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span>=&#123;</span>.owner=THIS_MODULE,.<span class="hljs-built_in">open</span>=demo_open,.<span class="hljs-built_in">write</span>=demo_write,.<span class="hljs-built_in">release</span>=demo_release,&#125;;<span class="hljs-comment">// 每个函数的的输入输出信息都可以使用source insight 在linux 源码中找到</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">demo_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> ret; <span class="hljs-comment">//0. 让内核分配给我们一个尚未使用的主设备号</span>ret=alloc_chrdev_region(&amp;devno,baseminor,dev_count,demo_name);<span class="hljs-comment">// 错误判断</span><span class="hljs-keyword">if</span> (ret&lt;<span class="hljs-number">0</span>)&#123;printk(KERN_INFO <span class="hljs-string">"alloc_chrdev_region  failed------\n"</span>);<span class="hljs-keyword">goto</span> err1;&#125;printk(KERN_INFO<span class="hljs-string">"major=%d\n"</span>,MAJOR(devno));  <span class="hljs-comment">//打印出申请的主设备号</span><span class="hljs-comment">//1. 申请cdev 结构体内存</span>demo_cdev=cdev_alloc();<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==demo_cdev)&#123;printk(KERN_INFO<span class="hljs-string">"demo_cdev  failed   --\n"</span>);<span class="hljs-keyword">goto</span> err2;&#125;<span class="hljs-comment">//2. 对cdev 结构体 进行初始化</span>cdev_init(demo_cdev,&amp;fops);<span class="hljs-comment">//3. 将cdev结构体加入到系统当中</span>ret=cdev_add(demo_cdev,devno,dev_count);<span class="hljs-keyword">if</span> (ret&lt;<span class="hljs-number">0</span>)&#123;printk(KERN_INFO<span class="hljs-string">"cdev_add  failed   --\n"</span>);<span class="hljs-keyword">goto</span> err2;&#125;    <span class="hljs-comment">//一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建  一个类，这个类存放于sysfs下面，</span>demo_class=class_create(THIS_MODULE,demo_name);<span class="hljs-keyword">if</span>(IS_ERR(demo_class))&#123;printk(KERN_INFO<span class="hljs-string">"class_create failed --\n"</span>);<span class="hljs-keyword">goto</span> err3;&#125;    <span class="hljs-comment">//调用device_create(…)函数来在/dev目录下创建相应的设备节点</span>device_create(demo_class,<span class="hljs-literal">NULL</span>,devno,<span class="hljs-literal">NULL</span>,demo_name);printk(KERN_INFO <span class="hljs-string">"---%s---%s---%d---\n"</span>,__FILE__,__func__,__LINE__);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;err3:cdev_del(demo_cdev);err2:unregister_chrdev_region(devno,dev_count);err1:<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">demo_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;class_destroy(demo_class);device_destroy(demo_class,devno);cdev_del(demo_cdev);unregister_chrdev_region(devno,dev_count);printk(KERN_INFO <span class="hljs-string">"---%s---%s---%d---\n"</span>,__FILE__,__func__,__LINE__);&#125;module_init(demo_init);module_exit(demo_exit);MODULE_LICENSE(<span class="hljs-string">"GPL"</span>); <span class="hljs-comment">//描述模块的许可证</span></code></pre></div></li></ul><h2 id="编译驱动模块"><a href="#编译驱动模块" class="headerlink" title="编译驱动模块"></a>编译驱动模块</h2><p>Makefile 文件如下    </p><div class="hljs"><pre><code class="hljs makefile">KDIR=/home/qiu/linux2.6.35-source/linux-2.6.35.3   <span class="hljs-comment">#内核路径</span><span class="hljs-section">all:</span>make -C <span class="hljs-variable">$(KDIR)</span> M=`pwd`  modules<span class="hljs-section">clean:</span>make -C <span class="hljs-variable">$(KDIR)</span> M=`pwd` modules cleanrm -f modules.orderobj-m+=led_drv1.o        <span class="hljs-comment">#obj-m +=xxx.o意思是该模块不会编译到zImage</span></code></pre></div><p>在该目录下使用make命令完成对 文件的编译    </p><h2 id="驱动测试代码"><a href="#驱动测试代码" class="headerlink" title="驱动测试代码"></a>驱动测试代码</h2><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> fd;      <span class="hljs-comment">//声明设备描述符</span>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>;  <span class="hljs-comment">//随便定义变量传入到</span>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/xxx"</span>,  O_RDWR);  <span class="hljs-comment">//根据路径打开设备</span>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//打开失败</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"can't open\n"</span>);      <span class="hljs-built_in">write</span>(fd, &amp;val, <span class="hljs-number">4</span>);  <span class="hljs-comment">//根据文件描述符调用write</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><hr><p>字符设备驱动这一部分还是学了很久的，算是自己linux驱动的入门吧，Makefile这一部分忘的差不多了，接下来补一补，接下来学习更多驱动相关的内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>雨梦OCR文字提取V3.94 使用教程</title>
    <link href="/2020/05/01/%E9%9B%A8%E6%A2%A6OCR%20V3.94%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2020/05/01/%E9%9B%A8%E6%A2%A6OCR%20V3.94%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="雨梦OCR-V3-94使用教程"><a href="#雨梦OCR-V3-94使用教程" class="headerlink" title="雨梦OCR V3.94使用教程"></a>雨梦OCR V3.94使用教程</h1><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li>截图提取文字 （提取到的文字会自动复制到粘贴板）  </li><li>拖拽提取文字 （可批量拖拽图片）</li><li>导入图片提取文字</li><li>贴图</li><li>截图功能，可以对图片进行修改保存</li><li>导出文本到word中或txt中</li><li>翻译功能，支持百度、腾讯和谷歌三种翻译接口，翻译方式有如下两种：   <ul><li>通过截图/导入图片等方式提取文字后，自动对文本进行翻译。    </li><li>通过Ctrl+c 复制文字后，自动提取文字并进行翻译(此功能会自动对多行进行合并)。    </li></ul></li><li>截图提取表格，并可导出表格。     </li></ul><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ol><li>到<a href="http://hanxinyumeng.cn" target="_blank" rel="noopener">官网</a>点击立即下载即可下载最新版软件。   </li><li>对下载得到的zip文件进行解压。</li><li>双击文件夹中的exe文件即可打开软件，软件界面如下：<br><img src="https://img.alicdn.com/imgextra/i2/1839819974/O1CN01A0mYls2NY8wbJoY9F_!!1839819974.jpg" srcset="/img/loading.gif" alt="软件主图">         </li></ol><h2 id="文字提取"><a href="#文字提取" class="headerlink" title="文字提取"></a>文字提取</h2><h3 id="截图提取演示："><a href="#截图提取演示：" class="headerlink" title="截图提取演示："></a>截图提取演示：</h3><p><img src="https://img.alicdn.com/imgextra/i4/1839819974/O1CN01o47X2I2NY8wgBLxrr_!!1839819974.gif" srcset="/img/loading.gif" alt="截图提取文字演示GIF">      </p><h3 id="拖拽提取演示："><a href="#拖拽提取演示：" class="headerlink" title="拖拽提取演示："></a>拖拽提取演示：</h3><ul><li><p><strong>拖拽图片到软件中，即可对其进行文字提取，也可以同时选多个图片进行拖拽</strong><br><img src="https://img.alicdn.com/imgextra/i3/1839819974/O1CN018lvBfY2NY8xWFVAnA_!!1839819974.gif" srcset="/img/loading.gif" alt="截图提取文字演示GIF">       </p><h3 id="文本提取说明："><a href="#文本提取说明：" class="headerlink" title="文本提取说明："></a>文本提取说明：</h3></li><li><p>调出截图提取文字的方法有如下几种：</p><ol><li>点击软件主界面的截图按钮。</li><li>使用截图提取文字快捷键，3.94版本默认为Alt+Z（以前的版本默认为F4），可以在设置界面自定义此快捷键。</li><li>左键单击电脑托盘图标</li></ol></li><li><p>文字提取成功后会自动复制到粘贴板。</p></li><li><p>软件默认使用中文标点，可以在设置更改为英文标点。</p></li><li><p>默认提取的语言是中英文，可以在设置中对语言进行更改。</p></li><li><p>可以在设置中对字体，大小，对齐方式进行调整。</p></li><li><p>可以对是否合并多行文本，是否多次提取结果叠加等进行设置。      </p><h3 id="OCR接口说明："><a href="#OCR接口说明：" class="headerlink" title="OCR接口说明："></a>OCR接口说明：</h3><p>目前V3.94版本具有四个OCR接口，接口具体信息如下：<br><img src="https://img.alicdn.com/imgextra/i4/1839819974/O1CN011hBrfw2NY8wcwniJy_!!1839819974.jpg" srcset="/img/loading.gif" alt="OCR接口说明表格">    </p></li></ul><ul><li><a href="http://www.hanxinyumeng.cn/post/baidu-OCR-application-course" target="_blank" rel="noopener">百度(个人账号)申请教程</a>    </li><li><a href="http://www.hanxinyumeng.cn/post/sogou-OCR-application-course" target="_blank" rel="noopener">搜狗(个人账号)申请教程</a>        </li></ul><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><ul><li>什么是贴图：贴图功能可以通过截图，把得到的图片放置在桌面的任意位置，对于做笔记，临时备忘等非常实用。</li><li>贴图默认快捷键Alt+Q,通过快捷键或右键托盘图标便可呼出此功能。<br>演示如下：<img src="https://img.alicdn.com/imgextra/i2/1839819974/O1CN01SJ07KD2NY8xR5IlAi_!!1839819974.gif" srcset="/img/loading.gif" alt="贴图"></li></ul><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul><li><p>可以像QQ截图一样对图片进行截取、修改和保存。</p></li><li><p>调出方法：    </p><ol><li>鼠标滚轮键单击软件托盘图标。    </li><li>使用快捷键，默认为Alt+X, 也可在设置中对其进行修改。        </li></ol></li></ul><h2 id="竖版文字提取使用说明"><a href="#竖版文字提取使用说明" class="headerlink" title="竖版文字提取使用说明"></a>竖版文字提取使用说明</h2><p>目前只有搜狗(个人账号)接口有竖版文字识别的功能，功能演示如下：<br><img src="https://img.alicdn.com/imgextra/i3/1839819974/O1CN01HQ45mx2NY8wZqAswr_!!1839819974.gif" srcset="/img/loading.gif" alt="竖版文字提取GIF"> </p><h2 id="翻译功能使用说明"><a href="#翻译功能使用说明" class="headerlink" title="翻译功能使用说明"></a>翻译功能使用说明</h2><p>目前翻译接口有百度、腾讯和谷歌，翻译功能主要有如下两种使用方法：    </p><ol><li>通过截图或导入图片后对得到的文本进行翻译，可以设置为自动翻译。   </li><li>使用Ctrl+c复制文本后进行翻译。（Ctrl+c复制文本后，软件会自动获取文本，并进行多行合并后翻译）    <h3 id="截图翻译演示"><a href="#截图翻译演示" class="headerlink" title="截图翻译演示"></a>截图翻译演示</h3><img src="https://img.alicdn.com/imgextra/i3/1839819974/O1CN01APYl3w2NY8wgBohHJ_!!1839819974.gif" srcset="/img/loading.gif" alt="截图提取文字翻译演示GIF">    <h3 id="粘贴板翻译演示"><a href="#粘贴板翻译演示" class="headerlink" title="粘贴板翻译演示"></a>粘贴板翻译演示</h3><img src="https://img.alicdn.com/imgextra/i2/1839819974/O1CN01sOgOq12NY8wZrpnt8_!!1839819974.gif" srcset="/img/loading.gif" alt="df">   </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>雨梦OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
